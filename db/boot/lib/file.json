[
  {
    "tags": [
      {
        "type": "author",
        "string": "$imon"
      },
      {
        "type": "since",
        "string": "1.0alpha1"
      }
    ],
    "description": {
      "full": "A library to manage files.",
      "summary": "A library to manage files.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false
  },
  {
    "tags": [],
    "description": {
      "full": "Base64 encode / decode\n http://www.webtoolkit.info/",
      "summary": "Base64 encode / decode\n http://www.webtoolkit.info/",
      "body": ""
    },
    "ignore": false,
    "code": "Webos.base64 = {",
    "ctx": {
      "type": "property",
      "receiver": "Webos",
      "name": "base64",
      "value": "{",
      "string": "Webos.base64"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "String containing base64 chars.",
      "summary": "String containing base64 chars.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "_keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\","
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "input",
        "description": "The string to encode."
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "The base64-encoded string."
      }
    ],
    "description": {
      "full": "Encode a string to base64.",
      "summary": "Encode a string to base64.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "encode: function (input) {\n\t\tif (window.btoa) {\n\t\t\treturn window.btoa(unescape(encodeURIComponent(input)));\n\t\t}\n\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\twhile (i < input.length) {\n \n\t\t\tchr1 = input.charCodeAt(i++);\n\t\t\tchr2 = input.charCodeAt(i++);\n\t\t\tchr3 = input.charCodeAt(i++);\n \n\t\t\tenc1 = chr1 >> 2;\n\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\tenc4 = chr3 & 63;\n \n\t\t\tif (isNaN(chr2)) {\n\t\t\t\tenc3 = enc4 = 64;\n\t\t\t} else if (isNaN(chr3)) {\n\t\t\t\tenc4 = 64;\n\t\t\t}\n \n\t\t\toutput = output +\n\t\t\tthis._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\n\t\t\tthis._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n \n\t\t}\n \n\t\treturn output;\n\t},",
    "ctx": {
      "type": "method",
      "name": "encode",
      "string": "undefined.prototype.encode()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "input",
        "description": "The base64-encoded string."
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "The decoded string."
      }
    ],
    "description": {
      "full": "Decode a base64-string.",
      "summary": "Decode a base64-string.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "decode: function (input) {\n\t\tif (window.atob) {\n\t\t\treturn decodeURIComponent(escape(window.atob(input)));\n\t\t}\n\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3;\n\t\tvar enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n \n\t\twhile (i < input.length) {\n \n\t\t\tenc1 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc2 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc3 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc4 = this._keyStr.indexOf(input.charAt(i++));\n \n\t\t\tchr1 = (enc1 << 2) | (enc2 >> 4);\n\t\t\tchr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n\t\t\tchr3 = ((enc3 & 3) << 6) | enc4;\n \n\t\t\toutput = output + String.fromCharCode(chr1);\n \n\t\t\tif (enc3 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr2);\n\t\t\t}\n\t\t\tif (enc4 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr3);\n\t\t\t}\n \n\t\t}\n \n\t\treturn output;\n\t},\n \n\t// method for UTF-8 encoding\n\tutf8Encode: function (string) {\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\n\t\tvar utftext = \"\";\n \n\t\tfor (var n = 0; n < string.length; n++) {\n \n\t\t\tvar c = string.charCodeAt(n);\n \n\t\t\tif (c < 128) {\n\t\t\t\tutftext += String.fromCharCode(c);\n\t\t\t}\n\t\t\telse if((c > 127) && (c < 2048)) {\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n \n\t\t}\n \n\t\treturn utftext;\n\t},\n \n\t// method for UTF-8 decoding\n\tutf8Decode: function (utftext) {\n\t\tvar string = \"\";\n\t\tvar i = 0;\n\t\tvar c = c1 = c2 = 0;\n \n\t\twhile ( i < utftext.length ) {\n \n\t\t\tc = utftext.charCodeAt(i);\n \n\t\t\tif (c < 128) {\n\t\t\t\tstring += String.fromCharCode(c);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if((c > 191) && (c < 224)) {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tstring += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tc3 = utftext.charCodeAt(i+2);\n\t\t\t\tstring += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t\ti += 3;\n\t\t\t}\n \n\t\t}\n \n\t\treturn string;\n\t}\n};",
    "ctx": {
      "type": "method",
      "name": "decode",
      "string": "undefined.prototype.decode()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The file's data."
      },
      {
        "type": "constructor",
        "string": ""
      },
      {
        "type": "augments",
        "otherClass": "{Webos.Model}"
      },
      {
        "type": "since",
        "string": "1.0alpha1"
      }
    ],
    "description": {
      "full": "`Webos.File` represents a file.\n\nListing files in the user's home folder :\n```js\nW.File.listDir('~', [function(files) { //We want to list files in the home folder (which is \"~\")\n   var list = 'Files : ';\n   for (var i = 0; i < files.length; i++) { //For each file\n      var file = files[i];\n      list += ' '+file.get('basename'); //Add the file to the list\n   }\n   alert(list); //Show the list\n}, function(response) { //An error occured\n   response.triggerError('Cannot list files in folder');\n}]);\n```\n",
      "summary": "`Webos.File` represents a file.",
      "body": "Listing files in the user's home folder :\n```js\nW.File.listDir('~', [function(files) { //We want to list files in the home folder (which is \"~\")\n   var list = 'Files : ';\n   for (var i = 0; i < files.length; i++) { //For each file\n      var file = files[i];\n      list += ' '+file.get('basename'); //Add the file to the list\n   }\n   alert(list); //Show the list\n}, function(response) { //An error occured\n   response.triggerError('Cannot list files in folder');\n}]);\n```\n"
    },
    "isPrivate": false,
    "isConstructor": true,
    "ignore": false,
    "code": "Webos.File = function WFile(data) {\n\tWebos.Model.call(this, data); //Inherits from Webos.Model\n};",
    "ctx": {
      "type": "constructor",
      "receiver": "Webos",
      "name": "File",
      "string": "Webos.File()"
    }
  },
  {
    "tags": [
      {
        "type": "namespace",
        "string": "Webos.File"
      }
    ],
    "description": {
      "full": "Webos.File's prototype.",
      "summary": "Webos.File's prototype.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.prototype = {",
    "ctx": {
      "type": "prototype",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "Webos.File",
      "string": "Webos.File.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The new data."
      }
    ],
    "description": {
      "full": "Update file's data, and complete automatically missing data.",
      "summary": "Update file's data, and complete automatically missing data.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "hydrate: function(data) {\n\t\tvar path = (data.path || this.get('path'));\n\t\tif (path) {\n\t\t\tif (!data.dirname) { //On définit automatiquement le dossier parent si non présent\n\t\t\t\tif (path.indexOf('/', 1) != -1) {\n\t\t\t\t\tdata.dirname = path.replace(/\\/[^\\/]*\\/?$/, '');\n\t\t\t\t} else if (path.indexOf('/') == -1 || path == '/') {\n\t\t\t\t\tdata.dirname = undefined;\n\t\t\t\t} else if (path.indexOf('/') == 0) {\n\t\t\t\t\tdata.dirname = '/';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!data.basename) { //On définit automatiquement le nom du fichier si non présent\n\t\t\t\tdata.basename = path.replace(/^.*[\\/\\\\]/g, '');\n\t\t\t}\n\t\t\tif (data.is_dir === false && !data.extension) { //On définit automatiquement l'extension du fichier si non présent et que le fichier n'est pas un dossier\n\t\t\t\tdata.extension = (/\\./.test(path)) ? /[^.]+$/.exec(path)[0] : '';\n\t\t\t}\n\t\t\tif (data.extension) { //On met l'extension en minuscules\n\t\t\t\tdata.extension = data.extension.toLowerCase();\n\t\t\t}\n\t\t}\n\n\t\tif (typeof data.is_binary == 'undefined') {\n\t\t\tif (data.mime_type) {\n\t\t\t\tdata.is_binary = (data.mime_type.indexOf('text/') != 0);\n\t\t\t} else if (!this.exists('is_binary')) {\n\t\t\t\tdata.is_binary = true;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof data.labels == 'undefined') {\n\t\t\tdata.labels = {};\n\t\t}\n\t\tif (!data.labels.hidden) {\n\t\t\tdata.labels.hidden = (data.basename.charAt(0) == '.');\n\t\t}\n\t\tif (typeof data.labels.trashed == 'undefined') {\n\t\t\tdata.labels.trashed = false;\n\t\t}\n\n\t\treturn Webos.Model.prototype.hydrate.call(this, data);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "hydrate",
      "string": "Webos.File.prototype.hydrate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The new data."
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "Update file's data.",
      "summary": "Update file's data.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "_updateData: function(data) {\n\t\tvar updatedData = {};\n\t\tfor (var key in data) {\n\t\t\tif (this._get(key) !== data[key]) {\n\t\t\t\tupdatedData[key] = data[key];\n\t\t\t}\n\t\t}\n\n\t\tvar oldPath = this.get('path');\n\n\t\t//Il FAUT creer une copie de l'objet \"updatedData\" sinon il sera modifie par la fonction \"this.hydrate\"\n\t\tthis.hydrate($.extend({}, updatedData));\n\n\t\tvar parentDirPath = this.get('dirname');\n\t\tif (parentDirPath != this.get('path')) { //Dossier racine ?\n\t\t\tif (Webos.File.isCached(parentDirPath)) {\n\t\t\t\tvar parentDir = Webos.File.get(parentDirPath);\n\t\t\t\tif (parentDir._contents) {\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (var i = 0; i < parentDir._contents.length; i++) {\n\t\t\t\t\t\tif (parentDir._contents[i].get('path') == this.get('path')) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tparentDir._contents.push(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar newPath = this.get('path');\n\n\t\tif (oldPath != newPath) {\n\t\t\tvar thisData = $.extend({}, this.data());\n\t\t\tthis.hydrate({\n\t\t\t\tpath: oldPath\n\t\t\t});\n\t\t\tthis._remove();\n\n\t\t\tvar file = Webos.File.get(newPath);\n\n\t\t\tif (Webos.isInstanceOf(file, this.constructor)) {\n\t\t\t\tfile._updateData(thisData);\n\t\t\t} else {\n\t\t\t\tfile._updateData({\n\t\t\t\t\tis_dir: thisData.is_dir\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var key in updatedData) {\n\t\t\t\tthis.notify('update', { key: key, value: updatedData[key] });\n\t\t\t}\n\n\t\t\tWebos.File.notify('load', { file: this });\n\t\t}\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "_updateData",
      "string": "Webos.File.prototype._updateData()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "Trigger post-removing callbacks.",
      "summary": "Trigger post-removing callbacks.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "_remove: function() {\n\t\tthis.notify('remove');\n\t\tWebos.File.notify('remove', { file: this });\n\n\t\tvar parentDirPath = this.get('dirname');\n\t\tif (parentDirPath != this.get('path')) { //Dossier racine ?\n\t\t\tif (Webos.File.isCached(parentDirPath)) {\n\t\t\t\tvar parentDir = Webos.File.get(parentDirPath);\n\t\t\t\tif (parentDir._contents) {\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tfor (var i = 0; i < parentDir._contents.length; i++) {\n\t\t\t\t\t\tif (parentDir._contents[i].get('path') != this.get('path')) {\n\t\t\t\t\t\t\tlist.push(parentDir._contents[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparentDir._contents = list;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tWebos.File.clearCache(this.get('path'));\n\n\t\tdelete this;\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "_remove",
      "string": "Webos.File.prototype._remove()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "[callback]",
        "description": "The callback function which will be called."
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "Trigger an error because the current action is unavailable on this type of file.",
      "summary": "Trigger an error because the current action is unavailable on this type of file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "_unsupportedMethod: function(callback) {\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tcallback.error(Webos.Callback.Result.error('Cannot execute this operation on this type of file \"'+this.get('path')+'\"'));\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "_unsupportedMethod",
      "string": "Webos.File.prototype._unsupportedMethod()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Load this file's data.",
      "summary": "Load this file's data.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "load: function(callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "load",
      "string": "Webos.File.prototype.load()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "newName",
        "description": "The new name for the file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Rename this file.",
      "summary": "Rename this file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "rename: function(newName, callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "rename",
      "string": "Webos.File.prototype.rename()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Delete this file.",
      "summary": "Delete this file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "remove: function(callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "remove",
      "string": "Webos.File.prototype.remove()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Read this file's content as text.",
      "summary": "Read this file's content as text.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "readAsText: function(callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "readAsText",
      "string": "Webos.File.prototype.readAsText()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback. If this file is a directory, an array of files will be provided."
      }
    ],
    "description": {
      "full": "Get this file/directory's content.",
      "summary": "Get this file/directory's content.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "contents: function(callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "contents",
      "string": "Webos.File.prototype.contents()"
    }
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "Since 1.0 alpha 3, you are supposed to use Webos.File#contents()."
      }
    ],
    "description": {
      "full": "Get this file/directory's content.",
      "summary": "Get this file/directory's content.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "getContents: function(callback) {\n\t\treturn this.contents(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "getContents",
      "string": "Webos.File.prototype.getContents()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "contents",
        "description": "The new content for this file."
      },
      {
        "type": "return",
        "types": [
          "Webos.ServerCall"
        ],
        "description": "The associated server call."
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "Write this file's content as text.",
      "summary": "Write this file's content as text.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "_writeAsText: function(contents) {\n\t\tthis._unsupportedMethod();\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "_writeAsText",
      "string": "Webos.File.prototype._writeAsText()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "contents",
        "description": "The new content for this file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Write this file's content as text.",
      "summary": "Write this file's content as text.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "writeAsText: function(contents, callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "writeAsText",
      "string": "Webos.File.prototype.writeAsText()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "contents",
        "description": "The new content for this file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "deprecated",
        "string": "Since 1.0 beta 1, use Webos.File#writeAsText()."
      }
    ],
    "description": {
      "full": "Write this file's content as text.",
      "summary": "Write this file's content as text.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "setContents: function(contents, callback) {\n\t\treturn this.writeAsText(contents, callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "setContents",
      "string": "Webos.File.prototype.setContents()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Share this file and get the public URL.",
      "summary": "Share this file and get the public URL.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "share: function(callback) {\n\t\tthis._unsupportedMethod(callback);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "share",
      "string": "Webos.File.prototype.share()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "auth",
        "description": "The name of the authorization. Can be \"read\" or \"write\"."
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": "True if the user can execute the specified action, false otherwise."
      }
    ],
    "description": {
      "full": "Check if the user can execute a given action on this file.",
      "summary": "Check if the user can execute a given action on this file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "can: function(auth) {\n\t\tvar attr = (auth == 'read') ? 'readable' : 'writable';\n\t\t\n\t\treturn this.get(attr);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "can",
      "string": "Webos.File.prototype.can()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "label",
        "description": "The label."
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": "True if the file has the given label, false otherwise."
      }
    ],
    "description": {
      "full": "Check if this file has a given label.",
      "summary": "Check if this file has a given label.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "is: function(label) {\n\t\treturn (this._get('labels') && this._get('labels')[label]) ? true : false;\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "is",
      "string": "Webos.File.prototype.is()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "auth",
        "description": "The name of the authorization. Can be \"read\" or \"write\"."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": "True if the user can execute the specified action, false otherwise."
      }
    ],
    "description": {
      "full": "Check if the user can execute a given action on this file. Trigger an error if not.",
      "summary": "Check if the user can execute a given action on this file. Trigger an error if not.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "checkAuthorization: function(auth, callback) {\n\t\tif (!this.can(auth)) {\n\t\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\t\n\t\t\tcallback.error(Webos.Callback.Result.error('Vous n\\'avez pas les droits requis pour ' + ((auth == 'read') ? 'ouvrir' : 'modifier') + ' le fichier \"' + this.get('path') + '\"'));\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "checkAuthorization",
      "string": "Webos.File.prototype.checkAuthorization()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Clear this file's cache.",
      "summary": "Clear this file's cache.",
      "body": ""
    },
    "ignore": false,
    "code": "clearCache: function(filepath) {\n\t\tif (typeof this._contents == 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (filepath && this.get('is_dir')) {\n\t\t\tvar list = [];\n\t\t\tfor (var i = 0; i < this._contents.length; i++) {\n\t\t\t\tif (this._contents[i].get('path') != filepath) {\n\t\t\t\t\tlist.push(this._contents[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._contents = list;\n\t\t} else {\n\t\t\tdelete this._contents;\n\t\t}\n\t},\n\ttoString: function() {\n\t\treturn this.get('path');\n\t}\n};\nWebos.inherit(Webos.File, Webos.Model); //Héritage de Webos.Model\n\nWebos.Observable.build(Webos.File); //On construit un objet observable depuis Webos.File",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File",
      "cons": "Webos.File",
      "name": "clearCache",
      "string": "Webos.File.prototype.clearCache()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Cache for files.",
      "summary": "Cache for files.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File._cache = {};"
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "List of mounted volumes.",
      "summary": "List of mounted volumes.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File._mountedDevices = {};"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "file",
        "description": "The path to the file."
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[data]",
        "description": "The file's data."
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "[disableCache]",
        "description": "If set to true, the file will not be stored in the cache."
      },
      {
        "type": "return",
        "types": [
          "Webos.File"
        ],
        "description": "The file."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Get a file.",
      "summary": "Get a file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.get = function(file, data, disableCache) {\n\tif (window.File && file instanceof window.File) { //Si c'est un objet natif File, on retorune un objet Webos.LocalFile\n\t\treturn new Webos.LocalFile(file);\n\t} else if (Webos.isInstanceOf(file, Webos.File)) { //Si c'est déja un objet Webos.File, on le retourne directement\n\t\treturn file;\n\t}\n\n\tif (typeof file == 'undefined') {\n\t\treturn;\n\t}\n\n\tpath = String(file);\n\t\n\t//Le fichier est-il dans un volume monte ?\n\tvar devices = Webos.File.mountedDevices();\n\tfor (var local in devices) {\n\t\tif (Webos.File.cleanPath(path).indexOf(local) == 0) {\n\t\t\tif (Webos.File.isCached(path)) { //Si le fichier est dans le cache\n\t\t\t\treturn Webos.File._cache[path];\n\t\t\t} else {\n\t\t\t\tfile = Webos[devices[local].get('driver')].get(path, devices[local], data);\n\t\t\t\tif (!disableCache) {\n\t\t\t\t\tWebos.File._cache[file.get('path')] = file;\n\t\t\t\t}\n\t\t\t\treturn file;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (Webos.File.isCached(path)) { //Si le fichier est dans le cache, on le retourne\n\t\treturn Webos.File._cache[path];\n\t} else {\n\t\t//Sinon, on crée un nouvel objet\n\t\tfile = new Webos.WebosFile($.extend({}, data, {\n\t\t\tpath: path\n\t\t}));\n\t\tif (!disableCache) {\n\t\t\tWebos.File._cache[file.get('path')] = file;\n\t\t}\n\t\treturn file;\n\t}\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "get",
      "string": "Webos.File.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "path",
        "description": "The path to the file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Load a file's metadata.",
      "summary": "Load a file's metadata.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.load = function(path, callback) {\n\tpath = String(path);\n\tcallback = Webos.Callback.toCallback(callback);\n\t\n\t//Ajouter un fichier au cache\n\tvar addFileToCacheFn = function(file) {\n\t\tif (typeof Webos.File._cache[file.get('path')] != 'undefined') {\n\t\t\tWebos.File._cache[file.get('path')]._hydrate(file.data());\n\t\t\tfile = Webos.File._cache[file.get('path')];\n\t\t\tWebos.File.notify('load', { file: file });\n\t\t} else {\n\t\t\tWebos.File._cache[file.get('path')] = file;\n\t\t}\n\t};\n\t\n\t//Le fichier est-il dans un volume monte ?\n\tvar devices = Webos.File.mountedDevices();\n\tfor (var local in devices) {\n\t\tif (Webos.File.cleanPath(path).indexOf(local) == 0) {\n\t\t\t(function(point) {\n\t\t\t\tWebos[point.get('driver')].load(path, point, [function(file) {\n\t\t\t\t\taddFileToCacheFn(file);\n\t\t\t\t\tcallback.success(file);\n\t\t\t\t}, callback.error]);\n\t\t\t})(devices[local]);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif (Webos.File.isCached(path)) { //Si le fichier est déja dans le cache, on le retourne\n\t\tcallback.success(Webos.File._cache[path]);\n\t} else { //Sinon, on le charge\n\t\tvar file = Webos.File.get(path, {}, false);\n\t\t\n\t\tfile.load(new Webos.Callback(function() {\n\t\t\t//On le stocke dans le cache\n\t\t\taddFileToCacheFn(file);\n\t\t\t\n\t\t\tcallback.success(file);\n\t\t}, callback.error));\n\t}\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "load",
      "string": "Webos.File.load()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "path",
        "description": "The path to the directory."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "List a directory's files.",
      "summary": "List a directory's files.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.listDir = function(path, callback) {\n\tcallback = Webos.Callback.toCallback(callback);\n\t\n\tvar file = Webos.File.get(path, { is_dir: true }); //On construit notre objet\n\n\t//Puis on récupére son contenu\n\tfile.contents([function(list) {\n\t\tcallback.success(list);\n\t}, callback.error]);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "listDir",
      "string": "Webos.File.listDir()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "path",
        "description": "The path to the new file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Create an empty file.",
      "summary": "Create an empty file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.createFile = function(path, callback) {\n\tcallback = Webos.Callback.toCallback(callback);\n\t\n\t//Le fichier est-il dans un volume monte ?\n\tvar devices = Webos.File.mountedDevices();\n\tfor (var local in devices) {\n\t\tif (Webos.File.cleanPath(path).indexOf(local) == 0) {\n\t\t\t(function(point) {\n\t\t\t\tWebos[point.get('driver')].createFile(path, point, [function(file) {\n\t\t\t\t\tcallback.success(file);\n\t\t\t\t}, callback.error]);\n\t\t\t})(devices[local]);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\treturn new Webos.ServerCall({\n\t\t'class': 'FileController',\n\t\tmethod: 'createFile',\n\t\targuments: {\n\t\t\tfile: path\n\t\t}\n\t}).load([function(response) {\n\t\tvar file = Webos.File.get(path);\n\t\tfile._updateData(response.getData());\n\t\tcallback.success(file);\n\t}, callback.error]);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "createFile",
      "string": "Webos.File.createFile()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "path",
        "description": "The path to the new folder."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Create a new folder.",
      "summary": "Create a new folder.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.createFolder = function(path, callback) {\n\tcallback = Webos.Callback.toCallback(callback);\n\t\n\t//Le fichier est-il dans un volume monte ?\n\tvar devices = Webos.File.mountedDevices();\n\tfor (var local in devices) {\n\t\tif (Webos.File.cleanPath(path).indexOf(local) == 0) {\n\t\t\t(function(point) {\n\t\t\t\tWebos[point.get('driver')].createFolder(path, point, [function(file) {\n\t\t\t\t\tcallback.success(file);\n\t\t\t\t}, callback.error]);\n\t\t\t})(devices[local]);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\treturn new Webos.ServerCall({\n\t\t'class': 'FileController',\n\t\tmethod: 'createFolder',\n\t\targuments: {\n\t\t\tfile: path\n\t\t}\n\t}).load([function(response) {\n\t\tvar file = Webos.File.get(path);\n\t\tfile._updateData(response.getData());\n\t\tcallback.success(file);\n\t}, callback.error]);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "createFolder",
      "string": "Webos.File.createFolder()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.File",
          "String"
        ],
        "name": "source",
        "description": "The source file."
      },
      {
        "type": "param",
        "types": [
          "Webos.File",
          "String"
        ],
        "name": "dest",
        "description": "The destination file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Copy a file.",
      "summary": "Copy a file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.copy = function(source, dest, callback) {\n\tsource = Webos.File.get(source);\n\tdest = Webos.File.get(dest);\n\tcallback = Webos.Callback.toCallback(callback);\n\n\tvar updateMetadataFn = function(source, dest, data) {\n\t\tvar metadataFile = new dest.constructor(data);\n\t\tvar file = Webos.File.get(metadataFile.get('path'));\n\t\tif (Webos.isInstanceOf(file, metadataFile.constructor)) {\n\t\t\tfile._updateData(metadataFile.data());\n\t\t} else {\n\t\t\tfile._updateData({\n\t\t\t\tis_dir: metadataFile.get('is_dir')\n\t\t\t});\n\t\t}\n\t\tfile._contents = source._contents;\n\t\t\n\t\treturn file;\n\t};\n\n\t//Copie cote serveur entre fichiers du webos\n\tif (Webos.isInstanceOf(source, Webos.WebosFile) && Webos.isInstanceOf(dest, Webos.WebosFile)) {\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'copy',\n\t\t\targuments: {\n\t\t\t\tsource: source.get('path'),\n\t\t\t\tdest: dest.get('path')\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tvar file = updateMetadataFn(source, dest, response.getData());\n\n\t\t\tcallback.success(file);\n\t\t}, callback.error]);\n\t}\n\n\t//Copie cote serveur entre fichiers du meme volume\n\tif (source.get('mountPoint') && dest.get('mountPoint')) {\n\t\tif (source.get('mountPoint') === dest.get('mountPoint')) {\n\t\t\tvar point = source.get('mountPoint');\n\n\t\t\tif (typeof Webos[point.get('driver')].copy == 'function') {\n\t\t\t\treturn Webos[point.get('driver')].copy(source, dest, point, [function (data) {\n\t\t\t\t\tvar file = updateMetadataFn(source, dest, data);\n\n\t\t\t\t\tcallback.success(file);\n\t\t\t\t}, callback.error]);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Copie entre volumes differents -> copie \"hardcore\" en full-JS\n\n\tvar copyDirFn = function(source, dest, callback) {\n\t\tcallback = Webos.Callback.toCallback(callback);\n\n\t\tvar filesList, dirCreated = false;\n\t\tvar createChildFilesFn = function(dest) {\n\t\t\tif (!filesList || !dirCreated) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (filesList.length == 0) {\n\t\t\t\tcallback.success();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar copiedFilesNbr = 0, errorsNbr = 0, errorRes;\n\n\t\t\tvar triggerCallbackFn = function() {\n\t\t\t\tif (copiedFilesNbr == filesList.length) {\n\t\t\t\t\tcallback.success(dest);\n\t\t\t\t} else if (errorRes && errorsNbr == 1) {\n\t\t\t\t\tcallback.error(errorRes);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < filesList.length; i++) {\n\t\t\t\t(function(file) {\n\t\t\t\t\tcopyFn(file, dest.get('path') + '/' + file.get('basename'), [function(newFile) {\n\t\t\t\t\t\tcopiedFilesNbr++;\n\t\t\t\t\t\ttriggerCallbackFn();\n\t\t\t\t\t}, function(response) {\n\t\t\t\t\t\terrorsNbr++;\n\t\t\t\t\t\terrorRes = response;\n\t\t\t\t\t\ttriggerCallbackFn();\n\t\t\t\t\t}]);\n\t\t\t\t})(filesList[i]);\n\t\t\t}\n\t\t};\n\n\t\tW.File.listDir(source, [function(list) {\n\t\t\tfilesList = list;\n\t\t\tcreateChildFilesFn(dest);\n\t\t}, callback.error]);\n\n\t\tif (dest.get('is_dir')) {\n\t\t\tdest = W.File.get(dest.get('path') + '/' + source.get('basename'));\n\t\t\tcopyDirFn(source, dest, callback);\n\t\t} else if (dest.get('is_dir') === false) {\n\t\t\tdest._unsupportedMethod(callback);\n\t\t} else {\n\t\t\tdest.load([function(dest) {\n\t\t\t\tcopyDirFn(source, dest, callback);\n\t\t\t}, function() {\n\t\t\t\tWebos.File.createFolder(dest, [function(dest) {\n\t\t\t\t\tdirCreated = true;\n\t\t\t\t\tcreateChildFilesFn(dest);\n\t\t\t\t}, callback.error]);\n\t\t\t}]);\n\t\t}\n\t};\n\n\tvar copyTextFileFn = function(source, dest, callback) {\n\t\tcallback = Webos.Callback.toCallback(callback);\n\n\t\tsource.readAsText([function(contents) {\n\t\t\tdest.writeAsText(contents, [function() {\n\t\t\t\tcallback.success(dest);\n\t\t\t}, callback.error]);\n\t\t}, callback.error]);\n\t};\n\n\tvar copyBinaryFileFn = function(source, dest, callback) {\n\t\tcallback = Webos.Callback.toCallback(callback);\n\n\t\tsource.readAsBinary([function(contents) {\n\t\t\tdest.writeAsBinary(contents, [function() {\n\t\t\t\tcallback.success(dest);\n\t\t\t}, callback.error]);\n\t\t}, callback.error]);\n\t};\n\n\tvar copyFn = function(source, dest, callback) {\n\t\tsource = Webos.File.get(source);\n\t\tdest = Webos.File.get(dest);\n\n\t\tif (source.get('is_dir')) {\n\t\t\tcopyDirFn(source, dest, callback);\n\t\t} else if (source.get('is_dir') === false) {\n\t\t\tif (dest.get('is_dir')) {\n\t\t\t\tdest = W.File.get(dest.get('path') + '/' + source.get('basename'));\n\t\t\t\tcopyFn(source, dest, callback);\n\t\t\t} else {\n\t\t\t\tif (source.get('is_binary') && typeof source.readAsBinary == 'function' && typeof dest.writeAsBinary == 'function') {\n\t\t\t\t\tcopyBinaryFileFn(source, dest, callback);\n\t\t\t\t} else {\n\t\t\t\t\tcopyTextFileFn(source, dest, callback);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsource.load([function(source) {\n\t\t\t\tcopyFn(source, dest, callback);\n\t\t\t}, callback.error]);\n\t\t}\n\t};\n\n\tcopyFn(source, dest, callback);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "copy",
      "string": "Webos.File.copy()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.File",
          "String"
        ],
        "name": "source",
        "description": "The source file."
      },
      {
        "type": "param",
        "types": [
          "Webos.File",
          "String"
        ],
        "name": "dest",
        "description": "The destination file."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Move a file.",
      "summary": "Move a file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.move = function(source, dest, callback) {\n\tsource = Webos.File.get(source);\n\tdest = Webos.File.get(dest);\n\tcallback = Webos.Callback.toCallback(callback);\n\n\tvar updateMetadataFn = function(source, dest, data) {\n\t\tvar contents = source._contents;\n\t\tsource._remove();\n\n\t\tvar metadataFile = new dest.constructor(data);\n\t\tvar file = Webos.File.get(metadataFile.get('path'));\n\t\tif (Webos.isInstanceOf(file, metadataFile.constructor)) {\n\t\t\tfile._updateData(metadataFile.data());\n\t\t} else {\n\t\t\tfile._updateData({\n\t\t\t\tis_dir: metadataFile.get('is_dir')\n\t\t\t});\n\t\t}\n\t\tfile._contents = contents;\n\t\t\n\t\treturn file;\n\t};\n\n\t//Deplacement cote serveur entre fichiers du webos\n\tif (Webos.isInstanceOf(source, Webos.WebosFile) && Webos.isInstanceOf(dest, Webos.WebosFile)) {\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'move',\n\t\t\targuments: {\n\t\t\t\tsource: source.get('path'),\n\t\t\t\tdest: dest.get('path')\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tvar file = updateMetadataFn(source, dest, response.getData());\n\n\t\t\tcallback.success(file);\n\t\t}, callback.error]);\n\t}\n\n\t//Deplacement cote serveur entre fichiers du meme volume\n\tif (source.get('mountPoint') && dest.get('mountPoint')) {\n\t\tif (source.get('mountPoint') === dest.get('mountPoint')) {\n\t\t\tvar point = source.get('mountPoint');\n\n\t\t\tif (typeof Webos[point.get('driver')].move == 'function') {\n\t\t\t\treturn Webos[point.get('driver')].move(source, dest, point, [function(data) {\n\t\t\t\t\tvar file = updateMetadataFn(source, dest, data);\n\t\t\t\t\t\n\t\t\t\t\tcallback.success(file);\n\t\t\t\t}, callback.error]);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Deplacement de fichiers de volumes differents -> deplacement \"hardcore\" en full-JS\n\tWebos.File.copy(source, dest, [function() {\n\t\tsource.remove([function() {\n\t\t\tcallback.success(dest);\n\t\t}, callback.error]);\n\t}, callback.error]);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "move",
      "string": "Webos.File.move()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "data",
        "description": "The result data."
      },
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "file",
        "description": "The file."
      }
    ],
    "description": {
      "full": "A search result item.",
      "summary": "A search result item.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.SearchResultItem = function(data, file) {\n\tWebos.Model.call(this, data);\n\n\tthis._file = file;\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "SearchResultItem",
      "string": "Webos.File.SearchResultItem()"
    }
  },
  {
    "tags": [
      {
        "type": "namespace",
        "string": "Webos.File.SearchResultItem"
      }
    ],
    "description": {
      "full": "Webos.File.SearchResultItem's prototype.",
      "summary": "Webos.File.SearchResultItem's prototype.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.SearchResultItem.prototype = {\n\thydrate: function(data) {\n\t\treturn Webos.Model.prototype.hydrate.call(this, $.extend({\n\t\t\tmatchesNbr: 1\n\t\t}, data));\n\t},",
    "ctx": {
      "type": "prototype",
      "constructor": "Webos.File.SearchResultItem",
      "cons": "Webos.File.SearchResultItem",
      "name": "Webos.File.SearchResultItem",
      "string": "Webos.File.SearchResultItem.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Webos.File"
        ],
        "description": "The file."
      }
    ],
    "description": {
      "full": "Get the result's file.",
      "summary": "Get the result's file.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "file: function() {\n\t\treturn this._file;\n\t}\n};\nWebos.inherit(Webos.File.SearchResultItem, Webos.Model);",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File.SearchResultItem",
      "cons": "Webos.File.SearchResultItem",
      "name": "file",
      "string": "Webos.File.SearchResultItem.prototype.file()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "options",
        "description": "Search's options."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      },
      {
        "type": "return",
        "types": [
          "Webos.Operation"
        ],
        "description": "The operation."
      }
    ],
    "description": {
      "full": "Search files.",
      "summary": "Search files.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.search = function(options, callback) {\n\toptions = $.extend({\n\t\tq: '',\n\t\tinDir: '~'\n\t}, options);\n\tsearchDir = Webos.File.get(options.inDir);\n\n\tvar operation = new Webos.Operation();\n\toperation.addCallbacks(callback);\n\n\tif (!options.q.trim()) {\n\t\toperation.setCompleted(Webos.Callback.Result.error('Empty search query'));\n\t\treturn operation;\n\t}\n\n\tvar searchesOpsList = [], searchesResults = [];\n\n\tvar addResults = function(results) {\n\t\tsearchesResults = searchesResults.concat(results);\n\t};\n\n\tif (Webos.isInstanceOf(searchDir, Webos.WebosFile)) {\n\t\t//Search in the webos's files\n\t\tsearchesOpsList.push(new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'search',\n\t\t\targuments: {\n\t\t\t\tquery: options.q,\n\t\t\t\tinDir: options.inDir\n\t\t\t}\n\t\t}).load([function(res) {\n\t\t\tvar data = res.getData();\n\t\t\tvar list = [];\n\t\t\tfor (var key in data) {\n\t\t\t\tvar webosFile = new Webos.WebosFile(data[key]);\n\t\t\t\tvar file = Webos.File.get(webosFile.get('path'));\n\t\t\t\tif (Webos.isInstanceOf(file, Webos.WebosFile)) {\n\t\t\t\t\tfile._updateData(webosFile.data());\n\t\t\t\t} else {\n\t\t\t\t\tfile._updateData({\n\t\t\t\t\t\tis_dir: webosFile.get('is_dir')\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tvar searchResult = new Webos.File.SearchResultItem({\n\t\t\t\t\tmatchesNbr: data[key].matchesNbr\n\t\t\t\t}, file);\n\t\t\t\tlist.push(searchResult);\n\t\t\t}\n\n\t\t\taddResults(list);\n\t\t}, function(res) {\n\t\t\toperation.trigger('error', {\n\t\t\t\tresult: res\n\t\t\t});\n\t\t}]));\n\t}\n\n\tvar mountedList = Webos.File.mountedDevices();\n\tfor (var localPath in mountedList) {\n\t\tvar mountedDev = mountedList[localPath];\n\n\t\tif (searchDir.get('path') == localPath || localPath.indexOf(searchDir.get('path')+'/') == 0) {\n\t\t\t//Search in this device\n\t\t\t//TODO\n\t\t}\n\t}\n\n\tvar searchesOps = Webos.Observable.group(searchesOpsList);\n\tsearchesOps.on('success', function() {\n\t\tif (searchesOps.observables().length > 1) {\n\t\t\tsearchesResults.sort(function(a, b) {\n\t\t\t\treturn b.get('matchesNbr') - a.get('matchesNbr');\n\t\t\t});\n\t\t}\n\n\t\toperation.setCompleted(searchesResults);\n\t});\n\n\treturn operation;\n};\nWebos.File.searchInCache = function() {};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "search",
      "string": "Webos.File.search()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "path",
        "description": "The path to the file."
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": "True if the file is in the cache, false otherwise."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Check if a file is in the cache.",
      "summary": "Check if a file is in the cache.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.isCached = function(path) {\n\treturn (typeof Webos.File._cache[path] != 'undefined');\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "isCached",
      "string": "Webos.File.isCached()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Webos.File"
        ],
        "name": "[path]",
        "description": "If specified, only the corresponding file's cache will be cleared."
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "[clearParentCache]",
        "description": "If set to true, the parent's cache will also be cleared."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Clear the cache.",
      "summary": "Clear the cache.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.clearCache = function(path, clearParentCache) {\n\tif (typeof path == 'undefined') {\n\t\tWebos.File._cache = {};\n\t} else {\n\t\tif (Webos.File._cache[path]) {\n\t\t\tvar file = Webos.File._cache[path], parentDirPath = file.get('dirname');\n\t\t\tif (parentDirPath != file.get('path')) { //Dossier racine ?\n\t\t\t\tif (Webos.File.isCached(parentDirPath)) {\n\t\t\t\t\tvar parentDir = Webos.File.get(parentDirPath);\n\t\t\t\t\tif (clearParentCache) {\n\t\t\t\t\t\tparentDir.clearCache();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDir.clearCache(file.get('path'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdelete Webos.File._cache[path];\n\t}\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "clearCache",
      "string": "Webos.File.clearCache()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "The path to clean."
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "The cleaned path."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Clean a path.",
      "summary": "Clean a path.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.cleanPath = function(path) {\n\tpath = String(path);\n\t\n\treturn path\n\t\t.replace(/\\/+/g, '/')\n\t\t.replace('/./', '/')\n\t\t.replace(/\\/\\.$/, '/')\n\t\t.replace(/(.+)\\/$/, '$1');\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "cleanPath",
      "string": "Webos.File.cleanPath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "bytes",
        "description": "The size to convert."
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "The converted size, followed by its unit."
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "Convert a size in bytes to a human-readable file size (e.g. 1024 -> 1 Kio).",
      "summary": "Convert a size in bytes to a human-readable file size (e.g. 1024 -> 1 Kio).",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.bytesToSize = function(bytes) {\n\tvar sizes = ['octets', 'Kio', 'Mio', 'Gio', 'Tio', 'Pio', 'Eio', 'Zio', 'Yio'];\n\tif (bytes <= 1)\n\t\treturn bytes+' octet';\n\tvar i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\n\treturn ((i == 0) ? (bytes / Math.pow(1024, i))\n\t\t\t: (bytes / Math.pow(1024, i)).toFixed(1))\n\t\t\t+ ' ' + sizes[i];\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "bytesToSize",
      "string": "Webos.File.bytesToSize()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The mount point's data."
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "local",
        "description": "The mount point's local path."
      },
      {
        "type": "constructor",
        "string": ""
      },
      {
        "type": "augments",
        "otherClass": "{Webos.Model}"
      },
      {
        "type": "since",
        "string": "1.0beta1"
      }
    ],
    "description": {
      "full": "A mount point.",
      "summary": "A mount point.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "ignore": false,
    "code": "Webos.File.MountPoint = function WMountPoint(data, local) {\n\tWebos.Model.call(this, data);\n\t\n\tthis._local = local;\n};",
    "ctx": {
      "type": "constructor",
      "receiver": "Webos.File",
      "name": "MountPoint",
      "string": "Webos.File.MountPoint()"
    }
  },
  {
    "tags": [
      {
        "type": "namespace",
        "string": "Webos.File.MountPoint"
      }
    ],
    "description": {
      "full": "Webos.File.MountPoint's prototype.",
      "summary": "Webos.File.MountPoint's prototype.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.MountPoint.prototype = {",
    "ctx": {
      "type": "prototype",
      "constructor": "Webos.File.MountPoint",
      "cons": "Webos.File.MountPoint",
      "name": "Webos.File.MountPoint",
      "string": "Webos.File.MountPoint.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "Get the local path.",
      "summary": "Get the local path.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "local: function() {\n\t\treturn this._local;\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File.MountPoint",
      "cons": "Webos.File.MountPoint",
      "name": "local",
      "string": "Webos.File.MountPoint.prototype.local()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The mount point's data."
      }
    ],
    "description": {
      "full": "Set this mount point's data.",
      "summary": "Set this mount point's data.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "setData: function(data) {\n\t\tthis._data.data = data;\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File.MountPoint",
      "cons": "Webos.File.MountPoint",
      "name": "setData",
      "string": "Webos.File.MountPoint.prototype.setData()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "Get this mount point's data.",
      "summary": "Get this mount point's data.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "data: function() {\n\t\treturn this._data.data;\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File.MountPoint",
      "cons": "Webos.File.MountPoint",
      "name": "data",
      "string": "Webos.File.MountPoint.prototype.data()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "The absolute path."
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "The path, relative to this mount point's local path."
      }
    ],
    "description": {
      "full": "Build a path relative to this mount point's local path from an absolute path.",
      "summary": "Build a path relative to this mount point's local path from an absolute path.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "getRelativePath: function(path) {\n\t\treturn Webos.File.cleanPath(String(path).replace(this.get('local'), this.get('remote') + '/'));\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File.MountPoint",
      "cons": "Webos.File.MountPoint",
      "name": "getRelativePath",
      "string": "Webos.File.MountPoint.prototype.getRelativePath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "The path, relative to this mount point's local path."
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "The absolute path."
      }
    ],
    "description": {
      "full": "Build an absolute path from a path relative to this mount point's local path.",
      "summary": "Build an absolute path from a path relative to this mount point's local path.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "getWebosPath: function(path) {\n\t\tif (!this.get('remote')) {\n\t\t\treturn Webos.File.cleanPath(this.get('local') + '/' + String(path));\n\t\t}\n\t\t\n\t\treturn Webos.File.cleanPath(String(path).replace(this.get('remote'), this.get('local') + '/'));\n\t}\n};\nWebos.inherit(Webos.File.MountPoint, Webos.Model);",
    "ctx": {
      "type": "method",
      "constructor": "Webos.File.MountPoint",
      "cons": "Webos.File.MountPoint",
      "name": "getWebosPath",
      "string": "Webos.File.MountPoint.prototype.getWebosPath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.File.MountPoint"
        ],
        "name": "point",
        "description": "The mount point."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Mount a device.",
      "summary": "Mount a device.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.mount = function(point, callback) {\n\tcallback = Webos.Callback.toCallback(callback);\n\t\n\tif (!Webos[point.get('driver')]) {\n\t\tcallback.error();\n\t\treturn;\n\t}\n\t\n\tif (Webos.File._mountedDevices[point.get('local')]) {\n\t\tcallback.error();\n\t\treturn;\n\t}\n\t\n\tvar mountFn = function() {\n\t\tvar mountFn = function() {\n\t\t\tWebos.File._mountedDevices[point.get('local')] = point;\n\t\t\tWebos.File.notify('mount', { local: point.get('local'), remote: point.get('remote'), driver: point.get('driver'), point: point });\n\t\t\t\n\t\t\tWebos.File.clearCache(point.get('local'), true);\n\n\t\t\tcallback.success(point);\n\t\t};\n\t\t\n\t\tif (typeof Webos[point.get('driver')].mount == 'function') {\n\t\t\tWebos[point.get('driver')].mount(point, [function(newPoint) {\n\t\t\t\tif (newPoint) {\n\t\t\t\t\tpoint = newPoint;\n\t\t\t\t}\n\t\t\t\tmountFn();\n\t\t\t}, callback.error]);\n\t\t} else {\n\t\t\tmountFn();\n\t\t}\n\t};\n\t\n\tvar init = true, devices = Webos.File.mountedDevices();\n\tfor (var index in devices) {\n\t\tif (devices[index].get('driver') == point.get('driver')) {\n\t\t\tinit = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (init && typeof Webos[point.get('driver')].init == 'function') {\n\t\tWebos[point.get('driver')].init([function() {\n\t\t\tmountFn();\n\t\t}, callback.error]);\n\t} else {\n\t\tmountFn();\n\t}\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "mount",
      "string": "Webos.File.mount()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "An object containing local paths and associated mount points."
      }
    ],
    "description": {
      "full": "Get a list of mounted devices.",
      "summary": "Get a list of mounted devices.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.mountedDevices = function() {\n\treturn Webos.File._mountedDevices;\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "mountedDevices",
      "string": "Webos.File.mountedDevices()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "local",
        "description": "The mount point's local path."
      },
      {
        "type": "return",
        "types": [
          "Webos.File.MountPoint"
        ],
        "description": "point The mount point."
      }
    ],
    "description": {
      "full": "Get a specific mount point, giving its local path.",
      "summary": "Get a specific mount point, giving its local path.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.getMountData = function(local) {\n\treturn Webos.File._mountedDevices[local];\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "getMountData",
      "string": "Webos.File.getMountData()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.File.MountPoint"
        ],
        "name": "point",
        "description": "The mount point."
      }
    ],
    "description": {
      "full": "Umount a device.",
      "summary": "Umount a device.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.umount = function(local) {\n\tif (Webos.File._mountedDevices[local]) {\n\t\tvar point = Webos.File._mountedDevices[local], data = { local: point.get('local'), driver: point.get('driver'), remote: point.get('remote'), point: point };\n\t\tdelete Webos.File._mountedDevices[local];\n\t\tWebos.File.notify('umount', data);\n\n\t\tWebos.File.clearCache(data.local, true);\n\t}\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "umount",
      "string": "Webos.File.umount()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      },
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "A list of all registered drivers.",
      "summary": "A list of all registered drivers.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File._drivers = {};"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "driverName",
        "description": "The driver's name."
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The driver's data."
      }
    ],
    "description": {
      "full": "Register a new file driver.",
      "summary": "Register a new file driver.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.registerDriver = function(driverName, data) {\n\tif (!Webos[driverName]) {\n\t\treturn false;\n\t}\n\t\n\tWebos.File._drivers[driverName] = {\n\t\ttitle: data.title,\n\t\ticon: data.icon,\n\t\tlib: data.lib\n\t};\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "registerDriver",
      "string": "Webos.File.registerDriver()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "driverName",
        "description": "The driver's name."
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "data The driver's data."
      }
    ],
    "description": {
      "full": "Get a driver's data, giving its name.",
      "summary": "Get a driver's data, giving its name.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.File.getDriverData = function(driverName) {\n\treturn Webos.File._drivers[driverName];\n};",
    "ctx": {
      "type": "method",
      "receiver": "Webos.File",
      "name": "getDriverData",
      "string": "Webos.File.getDriverData()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "The file's data."
      },
      {
        "type": "augments",
        "otherClass": "{Webos.File}"
      },
      {
        "type": "constructor",
        "string": ""
      },
      {
        "type": "since",
        "string": "1.0beta1"
      }
    ],
    "description": {
      "full": "A file on the webos's file system.",
      "summary": "A file on the webos's file system.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "ignore": false,
    "code": "Webos.WebosFile = function WWebosFile(data) {\n\tWebos.File.call(this, data); //On appelle la classe parente\n};",
    "ctx": {
      "type": "constructor",
      "receiver": "Webos",
      "name": "WebosFile",
      "string": "Webos.WebosFile()"
    }
  },
  {
    "tags": [
      {
        "type": "namespace",
        "string": "Webos.WebosFile"
      }
    ],
    "description": {
      "full": "Webos.WebosFile's prototype.",
      "summary": "Webos.WebosFile's prototype.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.WebosFile.prototype = {\n\thydrate: function(data) {\n\t\tif (data.path) {\n\t\t\tdata.path = Webos.File.cleanPath(data.path); //On nettoie le chemin recu\n\n\t\t\tif (!data.realpath) { //On définit automatiquement le chemin réel si non présent\n\t\t\t\tdata.realpath = 'sbin/rawdatacall.php?type=file&path='+data.path;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (typeof data.readable == 'undefined') {\n\t\t\tdata.readable = true;\n\t\t}\n\t\tif (typeof data.writable == 'undefined') {\n\t\t\tdata.writable = true;\n\t\t}\n\n\t\treturn Webos.File.prototype.hydrate.call(this, data);\n\t},\n\tload: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'getData',\n\t\t\targuments: {\n\t\t\t\tpath: this.get('path')\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tvar data = response.getData();\n\n\t\t\tthat._updateData(data);\n\n\t\t\tcallback.success(that);\n\t\t}, callback.error]);\n\t},\n\trename: function(newName, callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (!this.checkAuthorization('write', callback)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'rename',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path'),\n\t\t\t\tnewName: newName\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tvar data = response.getData();\n\n\t\t\tthat._updateData(data);\n\n\t\t\tcallback.success(that);\n\t\t}, callback.error]);\n\t},\n\tremove: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (!this.checkAuthorization('write', callback)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'delete',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path')\n\t\t\t}\n\t\t}).load([function() {\n\t\t\tthat._remove();\n\t\t\tcallback.success();\n\t\t}, callback.error]);\n\t},\n\treadAsText: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (!this.checkAuthorization('read', callback)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (typeof this._contents != 'undefined') {\n\t\t\tcallback.success(this._contents);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'getContents',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path')\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tthat.hydrate({\n\t\t\t\tis_dir: false\n\t\t\t});\n\n\t\t\tvar contents = response.getStandardChannel();\n\t\t\tthat._contents = contents;\n\t\t\tcallback.success(contents);\n\n\t\t\tthat.notify('updatecontents', { contents: contents });\n\t\t\tWebos.File.notify('load', { file: that });\n\t\t}, callback.error]);\n\t},\n\tcontents: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (!this.checkAuthorization('read', callback)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (typeof this._contents != 'undefined') {\n\t\t\tcallback.success(this._contents);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (this.get('is_dir')) {\n\t\t\treturn new Webos.ServerCall({\n\t\t\t\t'class': 'FileController',\n\t\t\t\tmethod: 'getContents',\n\t\t\t\targuments: {\n\t\t\t\t\tdir: this.get('path')\n\t\t\t\t}\n\t\t\t}).load([function(response) {\n\t\t\t\tvar data = response.getData();\n\t\t\t\tvar list = [];\n\t\t\t\tfor (var key in data) {\n\t\t\t\t\tvar webosFile = new Webos.WebosFile(data[key]);\n\t\t\t\t\tvar file = Webos.File.get(webosFile.get('path'));\n\t\t\t\t\tif (Webos.isInstanceOf(file, Webos.WebosFile)) {\n\t\t\t\t\t\tfile._updateData(webosFile.data());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfile._updateData({\n\t\t\t\t\t\t\tis_dir: webosFile.get('is_dir')\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(file);\n\t\t\t\t}\n\n\t\t\t\tthat._contents = list;\n\n\t\t\t\tcallback.success(list);\n\n\t\t\t\tthat.notify('updatecontents', { contents: list });\n\t\t\t\tWebos.File.notify('load', { file: that });\n\t\t\t}, callback.error]);\n\t\t} else {\n\t\t\treturn this.readAsText(callback);\n\t\t}\n\t},",
    "ctx": {
      "type": "prototype",
      "constructor": "Webos.WebosFile",
      "cons": "Webos.WebosFile",
      "name": "Webos.WebosFile",
      "string": "Webos.WebosFile.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Get this file's content, encoded in base64.",
      "summary": "Get this file's content, encoded in base64.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "readAsBinary: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\n\t\tif (this.get('is_dir')) {\n\t\t\tthis._unsupportedMethod(callback);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!this.checkAuthorization('read', callback)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'getAsBinary',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path')\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tthat.hydrate({\n\t\t\t\tis_dir: false\n\t\t\t});\n\t\t\t\n\t\t\tvar contents = response.getStandardChannel();\n\t\t\tcallback.success(contents);\n\t\t}, callback.error]);\n\t},\n\t_writeAsText: function(contents) {\n\t\tvar that = this;\n\t\t\n\t\tif (this.get('is_dir')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!this.can('write')) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar call = new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'setContents',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path'),\n\t\t\t\tcontents: contents\n\t\t\t}\n\t\t});\n\n\t\tcall.bind('success', function(data) {\n\t\t\tvar response = data.result;\n\n\t\t\tthat._contents = contents;\n\n\t\t\tthat.notify('updatecontents', { contents: contents });\n\n\t\t\tthat._updateData(response.getData());\n\t\t});\n\n\t\treturn call;\n\t},\n\twriteAsText: function(contents, callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (this.get('is_dir')) {\n\t\t\tthis._unsupportedMethod(callback);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!this.checkAuthorization('write', callback)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar call = this._writeAsText(contents);\n\n\t\treturn call.load([function(response) {\n\t\t\tthat._contents = contents;\n\n\t\t\tthat.notify('updatecontents', { contents: contents });\n\n\t\t\tthat._updateData(response.getData());\n\n\t\t\tcallback.success();\n\t\t}, callback.error]);\n\t},",
    "ctx": {
      "type": "method",
      "constructor": "Webos.WebosFile",
      "cons": "Webos.WebosFile",
      "name": "readAsBinary",
      "string": "Webos.WebosFile.prototype.readAsBinary()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "contents",
        "description": "The base64-encoded content."
      },
      {
        "type": "param",
        "types": [
          "Webos.Callback"
        ],
        "name": "callback",
        "description": "The callback."
      }
    ],
    "description": {
      "full": "Write this file's content, encoded in base64.",
      "summary": "Write this file's content, encoded in base64.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "writeAsBinary: function(contents, callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (this.get('is_dir')) {\n\t\t\tthis._unsupportedMethod(callback);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!this.checkAuthorization('write', callback)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'setContentsAsBinary',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path'),\n\t\t\t\tcontents: contents\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tthat._updateData(response.getData());\n\n\t\t\tcallback.success();\n\t\t}, callback.error]);\n\t},\n\tshare: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\n\t\tif (!this.checkAuthorization('write', callback)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn new Webos.ServerCall({\n\t\t\t'class': 'FileController',\n\t\t\tmethod: 'share',\n\t\t\targuments: {\n\t\t\t\tfile: that.get('path')\n\t\t\t}\n\t\t}).load([function(response) {\n\t\t\tvar shareData = response.getData();\n\n\t\t\tcallback.success(shareData);\n\t\t}, callback.error]);\n\t}\n};\nWebos.inherit(Webos.WebosFile, Webos.File); //Héritage de Webos.File",
    "ctx": {
      "type": "method",
      "constructor": "Webos.WebosFile",
      "cons": "Webos.WebosFile",
      "name": "writeAsBinary",
      "string": "Webos.WebosFile.prototype.writeAsBinary()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "File"
        ],
        "name": "file",
        "description": "The native File object."
      },
      {
        "type": "constructor",
        "string": ""
      },
      {
        "type": "augments",
        "otherClass": "{Webos.File}"
      },
      {
        "type": "since",
        "string": "1.0beta1"
      }
    ],
    "description": {
      "full": "A local file (i.e. a file which is on the user's computer).",
      "summary": "A local file (i.e. a file which is on the user's computer).",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "ignore": false,
    "code": "Webos.LocalFile = function WLocalFile(file) {\n\tthis._file = file;\n\t\n\tvar data = {};\n\t\n\tdata.basename = file.name || file.fileName;\n\tdata.path = data.basename;\n\tdata.dirname = '';\n\tdata.realpath = null;\n\tdata.is_dir = false;\n\tdata.size = file.size || file.fileSize;\n\tdata.extension = (/[.]/.exec(data.path)) ? /[^.]+$/.exec(data.path)[0] : null;\n\tdata.type = file.type;\n\t\n\tdata.readable = true;\n\tdata.writable = false;\n\t\n\tWebos.File.call(this, data); //On appelle la classe parente\n};",
    "ctx": {
      "type": "constructor",
      "receiver": "Webos",
      "name": "LocalFile",
      "string": "Webos.LocalFile()"
    }
  },
  {
    "tags": [
      {
        "type": "namespace",
        "string": "Webos.LocalFile"
      }
    ],
    "description": {
      "full": "Webos.LocalFile's prototype.",
      "summary": "Webos.LocalFile's prototype.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.LocalFile.prototype = {\n\trealpath: function() {\n\t\tif (!this._get('realpath')) {\n\t\t\tvar myURL = window.URL || window.webkitURL;\n\t\t\tif (myURL && myURL.createObjectURL) {\n\t\t\t\tthis.hydrate({\n\t\t\t\t\trealpath: myURL.createObjectURL(this._file)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this._get('realpath');\n\t},\n\tload: function(callback) {\n\t\tcallback = Webos.Callback.toCallback(callback);\n\n\t\tcallback.success(this);\n\t},\n\treadAsText: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (!window.FileReader) {\n\t\t\tcallback.error('La lecture de fichiers locaux n\\'est pas support&eacute;e par votre navigateur');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar reader = new FileReader();\n\t\treader.onload = function(e) {\n\t\t\tcallback.success(e.target.result);\n\t\t};\n\t\treader.onerror = function(e) {\n\t\t\tcallback.error(e.target.result);\n\t\t};\n\t\treader.readAsText(this._file);\n\t},\n\treadAsBinary: function(callback) {\n\t\tvar that = this;\n\t\tcallback = Webos.Callback.toCallback(callback);\n\t\t\n\t\tif (!window.FileReader) {\n\t\t\tcallback.error('La lecture de fichiers locaux n\\'est pas support&eacute;e par votre navigateur');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar reader = new FileReader();\n\t\treader.onload = function(e) {\n\t\t\tvar contents = e.target.result;\n\t\t\tcontents = contents.replace(/^data:[a-zA-Z0-9-_\\/]+;base64,/, '');\n\t\t\tcallback.success(contents);\n\t\t};\n\t\treader.onerror = function(e) {\n\t\t\tcallback.error(e.target.result);\n\t\t};\n\t\treader.readAsDataURL(this._file);\n\t}\n};\nWebos.inherit(Webos.LocalFile, Webos.File); //Héritage de Webos.File",
    "ctx": {
      "type": "prototype",
      "constructor": "Webos.LocalFile",
      "cons": "Webos.LocalFile",
      "name": "Webos.LocalFile",
      "string": "Webos.LocalFile.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      }
    ],
    "description": {
      "full": "True if local files are supported.",
      "summary": "True if local files are supported.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "code": "Webos.LocalFile.support = (window.File && window.FileReader) ? true : false;\n\n\n//Events\nWebos.User.bind('login logout', function() {\n\t//Lorsque l'utilisateur quitte sa session, on vide le cache\n\tWebos.File.clearCache();\n});\nWebos.User.bind('logout', function() {\n\t//On demonte tous les volumes\n\tfor (var local in Webos.File.mountedDevices()) {\n\t\tWebos.File.umount(local);\n\t}\n});\n\nnew Webos.ScriptFile('/usr/lib/webos/fstab.js');"
  }
]